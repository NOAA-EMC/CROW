#! /bin/sh
#BSUB -q debug
#BSUB -P HUR-T2O
#BSUB -J final
#BSUB -o /gpfs/hps3/emc/hwrf/noscrub/Bin.Liu/save/gitCROW/model/ecflow_fv3gfs/scripts//output/final.log
#BSUB -W 0:05
#BSUB -R rusage[mem=3072]
#BSUB -n 1

set -xe  # print commands as they are executed and enable signal trapping

# Variables needed for communication with ecFlow version 4.5.0
export ECF_NAME=/prod00/final/alias0
#export ECF_NODE=nid02178
export ECF_NODE=ldecflow1
export ECF_PORT=31671
export ECF_PASS=h4UxEw37
export ECF_TRYNO=1
export ECF_RID=$LSB_JOBID

# Tell ecFlow we have started
if [ -d /opt/modules ]; then
    . /opt/modules/default/init/sh
else
    . /usrx/local/Modules/default/init/sh
fi
module load ecflow
ecflow_client --init=${ECF_RID}

## Enable LSF to communicate with ecFlow
if [ -d /var/lsf ]; then  # IBM iDataPlex nodes
  POST_OUT=/var/lsf/ecflow_post_in.$LSB_BATCH_JID
else  # Cray XC40 nodes
  POST_OUT=${POST_OUT:-/gpfs/hps/tmpfs/ecflow/ecflow_post_in.$LSB_BATCH_JID}
fi
cat > $POST_OUT <<ENDFILE
ECF_NAME=${ECF_NAME}
ECF_NODE=${ECF_NODE}
ECF_PORT=${ECF_PORT}
ECF_PASS=${ECF_PASS}
ECF_TRYNO=${ECF_TRYNO}
ECF_RID=${ECF_RID}
ENDFILE

# Define error handler
ERROR() {
  set +ex
  if [ "$1" -eq 0 ]; then
     msg="Killed by signal (likely via bkill)"
  else
     msg="Killed by signal $1"
  fi
  ecflow_client --abort="$msg"
  echo $msg
  echo "Trap Caught" >>$POST_OUT
  trap $1; exit $1
}
# Trap all error and exit signals
trap 'ERROR $?' ERR EXIT

echo ${JOBgfs}/final
ecflow_client --complete  # Notify ecFlow of a normal end
trap 0                    # Remove all traps
exit 0                    # End the shell
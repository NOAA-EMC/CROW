<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>CROW: Structures</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CROW
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">&#39;CROWimplementationforGlobal-Workflow&#39;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Structures </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>YAML in general</p>
<p>YAML(acronym of “YAML Ain't Markup Language”) is a human-readable data serialization language. Native YAML encodes data types that are specifically suitable for configuration. In this application, an enhanced format called CROW-YAML is developed along with a series of advanced functionalities and data types to support the configuration of the workflows of NOAA.</p>
<p>The CROW package has two-way conversion functions between YAML text files and configuration suite in memory. The configuration suite is essentially a python dictionary with all configuration settings. The settings are then parsed into config files, rocoto XML and ecFlow suite.</p>
<p>Processing of YAML files</p>
<p>As a serialization language, YAML is extremely suitable to handle configuration practice because of it’s keyword-free syntax, highly human-readable nature, and the conveniency of handling multiple types of value within a single object.</p>
<p>This data structure is then read by a Python YAML toolbox called PyYAML. The primary function of PyYAML is two-way conversion between a YAML text file and a python object. Please note that YAML can be read by all major programming languages (Perl, Ruby, C++, Java…… ) when proper libraries are provided. Python is chosen for this project because it’s growing popularity in NCEP.</p>
<p>CROW YAML is developed on top of PyYAML with the addition of several customized data types. User-defined data type is named alpha-numerically with “!” at the beginning when calling. CROW defines several of these to handle calculations, conditionals, templates, times, dependencies, and some others.</p>
<p>Features: Only once. Though not recommended, CROW enables users to specify a certain variable and override it at a later stage. But, only one value of a certain variable could be passed into the targeted workflow that is generated. All or none. CROW always reads all YAML files at one time. This design helps ensure consistency within the Configuration Suite and Workflow Suite. Diagnosable. In CROW, the experiment directory has effectively become a “checkpoint” for the configuration. This helps minimize human error and increase accountability, comparing with manually editing throughout experiment directory.</p>
<p>This file will be read by crow.config and become a eval_dict object of python. There are two sections in the eval_dict created, original contents are stored in _child and calculated values are stored in _cache.</p>
<p>CROW based workflow suite</p>
<p>CROW is a python based toolbox driven by a series of shell based utility scripts. In CROW-enabled modeling systems, top level directory /workflow is the designated place to start working with workflow generation. Under this directory locates the sub-repository CROW. Users need to perform a “git submodule” command to pull CROW from the cloud. Outside CROW repository, a user.yaml file and a case/ directory is needed to accommodate user and case settings. In addition to these, CROW needs a set of background files to fulfill its functionality. These files are stored in workflow/defaults; workflow/workflow; workflow/runtime; workflow/platforms and /schema.</p>
<p>As stated before, CROW uses a two-step approach to generate a workflow. The first step is called Configuration. In this step, CROW will detect the running platform and read in all YAML files to make sure all required variables are properly set. If no problem occurs, a Configuration Suite will be generated. The Configuration Suite is a virtual object in the form of python ecal_dict, which is essentially a database which only exists in memory. In the end, CROW will rewrite all input YAMLs into experiment directory, which is created in the beginning of this step, and parse all configuration variables to config files into the experiment directory.</p>
<p>Namely, a configuration suite contains all configuration information of a given experiment, including default settings (clock, alarm) and most importantly, a series of tasks with dependencies between each other. A suite can be defined over one or more cycles, while each task has a section to define which cycle it will run.</p>
<p>CROW Step 1, Configuration Flag-shaped boxes are text files; Circular bins are python objects; Yellow: User input files; Red: Background configuration files Green: Output files;</p>
<p>In the second step, named Generation, CROW will read in all YAML files and generate the Configuration Suite again, while also populate all tasks, along with suite default settings, onto designated cycles to generate a Workflow Suite, with choice of Rocoto or ecFlow as workflow manager.</p>
<p>CROW Step 2, Generation Flag-shaped boxes are text files; Circular bins are python objects; Yellow: User input files; Red: Background configuration files Green: Output files;</p>
<p>The basic component of a CROW configuration suite is called a task. In a workflow, a task is a single element or step of the modeling system providing a certain functionality by a set of scripts (For example: gdasefcs01). Inside CROW toolbox, a task is represented by python objects. Most tasks are associated with a J-Job script which handles submission of a supercomputing job card, with specific resource requests (time, cpu, memory ...). Some tasks come as an array called a “taskarray”, where multiple tasks performing the same functionality are grouped together (ie, gfs_post_XX, enkf_forecast_XX …..). Tasks will be instantiated as “jobs” when the workflow suite is generated and submitted to the workflow manager (For example: gdasefcs01 at 00 cycle and 06 cycle are two distinct jobs, but are derivatives of the same task gdasefcs01).</p>
<p>Fig 3. Detailed explanation of how tasks are defined will be given later</p>
<p>Example of task object creation:</p>
<p>This is what has been defined in task_schema (rocoto section) : task_schema: &amp;task_schema !Template Rocoto: # Variable name description: &gt;- # Short description XML to insert in the task definition, excluding the task tag itself, and the dependencies. type: string # Variable type stages: [ execution ] # Validation stage rocoto_command: description: &gt;- Command to execute for this task when run in rocoto. This is inserted into the rocoto command tag for the task. type: string stages: [ execution ] …(More variables)... This is what has been inherited and defined in task_template, only the rocoto parts are shown: task_template: &amp;task_template Template: *task_schema # Load task_schema Rocoto: !expand | # “|” for multi-line string </p>
<h1>actual string with {} to be filled by other variables</h1>
<p>&lt;command&gt;sh -c '{rocoto_command}'&lt;/command&gt; {partition.scheduler.rocoto_accounting( partition_specification,default_accounting,accounting, jobname=task_path_var, outerr=rocoto_log_path, partition=partition.specification)} rocoto_command: !expand &gt;- # actual string with {} {rocoto_load_modules} ; {rocoto_config_source} ; {J_JOB_PATH}/{J_JOB} &lt;envar&gt;&lt;name&gt;CDATE&lt;/name&gt;</p>
<p>&lt;cyclestr&gt;&lt;/cyclestr&gt;</p>
<p>&lt;/envar&gt; …(More lines of rocoto contents like the line above)... …(More variables)...</p>
<p>This is what has been inherited and defined in forecast_task_template, forecast_task_template: &amp;exclusive_task_template # This is a task template &lt;&lt;: *task_template # It loads this template partition: !calc doc.accounting.exclusive_partition # Running on this partition default_accounting: !calc partition.exclusive_accounting_ref </p>
<h1>default accounting</h1>
<p>J_JOB: !expand '{task_path_list[-1].upper()}' # interface for J_Job task_type: forecast # sticker</p>
<p>This is an actual task in the YAML configuration suite: jgdas_forecast_high: !Task # This is a task &lt;&lt;: *forecast_task_template # It loads this template Trigger: !Depend ( up.analysis.jgdas_analysis_high ) | ~ suite.has_cycle('-6:00:00') # This is the dependecies resources: !calc partition.resources.run_gdasfcst </p>
<h1>This is resource request</h1>
<p>J_JOB: JGLOBAL_FORECAST # This is the associated J-Job</p>
<p>This is the task in Rocoto XML generated from CROW:</p>
<p>&lt;task name="gdas.forecast.jgdas_forecast_high" maxtries="5"&gt; &lt;command&gt;sh -c ' source $HOMEgfs/ush/load_fv3gfs_modules.sh exclusive ; module list ; source $EXPDIR/config.base ; $HOMEgfs/jobs/JGLOBAL_FORECAST'&lt;/command&gt; &lt;queue&gt;&lt;/queue&gt; &lt;account&gt;&lt;/account&gt; &lt;jobname&gt;gdas.forecast.jgdas_forecast_high&lt;/jobname&gt; &lt;join&gt;&lt;cyclestr&gt;//gdas.forecast.jgdas_forecast_high.log&lt;/cyclestr&gt;&lt;/join&gt;</p>
<p>&lt;walltime&gt;0:30:00&lt;/walltime&gt; &lt;memory&gt;1024M&lt;/memory&gt; &lt;nodes&gt;1:ppn=4+2:ppn=3&lt;/nodes&gt;</p>
<p>&lt;envar&gt;&lt;name&gt;CDATE&lt;/name&gt;</p>
<p>&lt;cyclestr&gt;&lt;/cyclestr&gt;</p>
<p>&lt;/envar&gt; &lt;envar&gt;&lt;name&gt;PDY&lt;/name&gt;</p>
<p>&lt;cyclestr&gt;&lt;/cyclestr&gt;</p>
<p>&lt;/envar&gt; &lt;envar&gt;&lt;name&gt;cyc&lt;/name&gt;</p>
<p>&lt;cyclestr&gt;&lt;/cyclestr&gt;</p>
<p>&lt;/envar&gt; &lt;envar&gt;&lt;name&gt;EXPDIR&lt;/name&gt;</p>
<p>&lt;/envar&gt; &lt;envar&gt;&lt;name&gt;DUMP&lt;/name&gt;</p>
<p>gdas</p>
<p>&lt;/envar&gt; &lt;envar&gt;&lt;name&gt;RUN_ENVIR&lt;/name&gt;</p>
<p>emc</p>
<p>&lt;/envar&gt; &lt;envar&gt;&lt;name&gt;HOMEgfs&lt;/name&gt;</p>
<p>&lt;/envar&gt; &lt;envar&gt;&lt;name&gt;HOMEobsproc_network&lt;/name&gt;</p>
<p>&lt;/envar&gt; &lt;envar&gt;&lt;name&gt;HOMEobsproc_global&lt;/name&gt;</p>
<p>&lt;/envar&gt; &lt;envar&gt;&lt;name&gt;HOMEobsproc_prep&lt;/name&gt;</p>
<p>&lt;/envar&gt; &lt;envar&gt;&lt;name&gt;job&lt;/name&gt;</p>
<p>jgdas_forecast_high_&lt;cyclestr&gt;&lt;/cyclestr&gt;</p>
<p>&lt;/envar&gt;</p>
<pre class="fragment">    &lt;dependency&gt;
          &lt;or&gt;
                &lt;taskdep task="gdas.analysis.jgdas_analysis_high"/&gt;
                &lt;not&gt;
                      &lt;cycleexistdep cycle_offset="-06:00:00"/&gt;
                &lt;/not&gt;
          &lt;/or&gt;
    &lt;/dependency&gt;
</pre><p> &lt;/task&gt;</p>
<p>Fig 4. Relationship between Configuration Suite and Workflow Suite</p>
<p>At this moment, configuration settings of each individual task are still coming from the corresponding config.xx files which is then linked to task. The purpose of this design is to make the transition easier for users of legacy configuration system.</p>
<p>User Input Files Format</p>
<p>The YAML files that require user inputs are all formatted in a classical and intuitive “Name: Value” convention. Python-style indentation rule is applied to differentiate multiple levels of variable sections. Top level named is “case” for case file; while “user_places” and “accounting” is used for user file. Lower levels of contents include required and optional subsections. Order does not matter.</p>
<p>case: fv3_settings: CASE: C768 LEVS: 65</p>
<p>fv3_enkf_settings: CASE: C384</p>
<p>……</p>
<p>User file</p>
<p>user.yaml</p>
<p>This file contains user-specific information of a given computing platform. Two sections “user_places” and “accounting” are included.</p>
<p>A template of this file named “user.yaml.default” is included in the repository under workflow/. Users need to make their own “user.yaml” by modifying the values within the template when running CROW for the first time.</p>
<p>user_places: This section is of the same structure as “places” in case.yaml. The intention is to include settings that are more connected to the user other than the experiment. Such variables are marked red in the list. However, the user has the freedom to put all these variables into either one. When a certain variable get specified in both files, the one in this section will overwrite the one within case.yaml.</p>
<p>accounting: This section is designed to accommodate settings of supercomputer account and queue information.</p>
<p>Case file</p>
<p>[case name].yaml</p>
<p>This file serves as the central place to configure the experiment parameters, located under /workflow/cases. Configurable variables are categorized by “group” for better handling and indexing. Complete list of variables for each group are given in the Appendix.</p>
<p>case name is a required argument of setup_case.sh. When executed, the program will look for case name is workflow/cases directory to match the correct case file. A user may provide the full name of the yaml file as well (e.g. case_name.yaml), the system can handle both.</p>
<p>“Default value: None” here means that no “group level” default values provided. But most of the variables still have an “individual” default value defined in the schema. Detail about the “default system” will be discussed later in the /default and /schema section.</p>
<p>fv3_settings: Define spatial/vertical resolution and various physics parameters for deterministic and ensemble forecast jobs. Template: fv3_settings_template Default values: None</p>
<p>fv3_gfs_settings: settings for gfs (long forecast) model Template: fv3_settings_template Default values: None</p>
<p>fv3_enkf_settings: settings for DA ensemble forecast Template: fv3_settings_template Default values: fv3_enkf_defaults</p>
<p>fv3_gdas_settings: settings for DA deterministic forecast Template: fv3_settings_template Default values: None</p>
<p>For all four sections above, same variable list are provided. The gfs, enkf and gdas settings will inherit “fv3_settings” if not specified separately.</p>
<p>schedvar: Scheduler-related variables. Template: schedvar_schema Default: schedvar_defaults</p>
<p>gfs_output_settings: Model output settings Template: gfs_output_settings_template Default: gfs_output_settings_defaults</p>
<p>data_assimilation: Data assimilation configuration Template: data_assimilation_template Default: None</p>
<p>post: Post-processing configuration Template: post_schema Default: None</p>
<p>downstream: Switches for turning on/off downstream jobs Template: downstream_schema Default: downstream_defaults</p>
<p>places: Settings of paths. Also need to specify which workflow files is used to create the final workflow. Template: places_schema Default: default_places</p>
<p>nsst: Near Sea Surface Temperature scheme settings. exclusive_resources, shared_resources, service_resources: Resource specifications, default settings in platform file. Template: nsst_schema Default: None</p>
<p>settings: general settings, like SDATE, EDATE and if “four cycle mode” will be used. Template: settings_schema Default: default_settings</p>
<p>archiving: Settings for archiving data Template: archive_settings_template Default: None</p>
<p>Suite_overrides: Overriding values for the entire suite. No template is given.</p>
<p>Utility scripts:</p>
<p>Three most important utility scripts for the CROW system, setup_case.sh, make_rocoto_xml_for.sh and make_ecflow_file_for.sh, are already discussed in the section above. There are several additional scripts come with the package for various functionalities.</p>
<p>eclipse_main.py</p>
<p>Usage: python3.6 eclipse_main.py</p>
<p>This script is a python-based version of the setup_case.sh. The purpose of this version is to provide the conveniency of launching IDE projects (ie: Eclipse) since most of them only support projects with only one language inside. It will do the following things: Validate platform; Set up COMROT directory under ptmp location, which is typically specified in user.yaml; Set up experiment directory under PROJECT_DIR location, which is typically specified inside user.yaml; Create a configuration suite by reading all YAML files; A configuration suite is a python dictionary containing all configuration information. This suite is for validation and config file writing purpose and will only exist in memory. Write out all YAML files and config files into experiment directory.</p>
<p>ecflow_main.py / rocoto_main.py</p>
<p>Usage: python3.6 eclipse_main.py python3.6 rocoto_main.py</p>
<p>This file is the python equivalent to “make_ecflow_file_for.sh” / “make_rocoto_file_for.sh” as the entry point of “generation” step for ecflow or rocoto workflow generation.</p>
<p>worktools.py</p>
<p>This script is the central place to put top-level python functions regarding the handling of configuration definition documents and setting up the workflow.</p>
<p>Background Files Config</p>
<p>This directory stores the templates of all config files. For most modeling systems, it is usually a direct copy of “parm/config” directory.</p>
<p>Config files are bash shell scripts named “config.XXX” while “XXX” usually stands for a specific workflow task (example: config.fcst; config.post). These files store configurable variables for job “XXX” for later use in J-Jobs and ex-scripts. In addition to that, there are config.base and config.resource for general settings and resource allotment. When the model runs, each J-Job script will read in one or several of these files.</p>
<p>platform</p>
<p>This directory stores designated YAML files for each supported computing platform. For a given platform that supports the target workflow, the following parameters are defined:</p>
<p>Evaluate: this must be "false" to ensure disk space availability logic is not run unless this file is for the current platform. name: for machine name. detect: The detect criteria (like top level file structure) public_release_ics: location of input conditions that have been prepared for the public release CHGRP_RSTPROD_COMMAND: rstprod data command. NWPROD: location of NCEP operational directory. DMPDIR: location of the global dump data RTMFIX: location of the CRTM fixed data files used by the GSI data assimilation BASE_GIT: git command path. partitions: A comprehensive subsection, some machine comes with partitions like rdhpcs-jet. Resource allocation by partition are specified here. (partition detail) Least_used_temp: return the least used tmp directory.</p>
<p>workflow</p>
<p>This directory stores different type of workflow layouts associated with a certain modeling system. For example, cycled vs forecast-only for Global Workflow. In each workflow file, a sequence of tasks, or family of tasks, are given in an orderly manner. Job dependencies are also addressed in this file.</p>
<p>schema</p>
<p>This directory serves as a template for the configurations system for a given workflow. For each of the [case section].yaml files within this directory, each file gives all possible values for a certain section of the workflow.</p>
<p>The schema/task.yaml sets up task interfaces and defines a template for tasks at the top level. After this step, workflow/runtime/task.yaml will implement all these interfaces (ie, “ecf_file”, “rocoto_command”... ) with actual content regarding workflow manager information, which is then instantiated /subclassed in the actual workflow. This process can be viewed as a practice of class inheritance in object-oriented programming.</p>
<p>Fig 3. Detailed explanation of how tasks are defined will be given later</p>
<p>runtime</p>
<p>This is the section for a series of task templates, as together with a series of suite default sections of rocoto and ecFlow. For example, templates for the rocoto “header” section</p>
<p>suite.yaml: Defines virtual object “suite_default” which represents utilities and common sections which are shared through the entire workflow.</p>
<p>defaults</p>
<p>This directory stores default value for each part of the workflow. Comparing to the default values defined in /schema, this directory focuses on “group” default grouped by categories. These default values, if defined, will overwrite default values in schema. This section is organized in “group”s which is also housing all customized variables in the case file. Adding this section make configuration more manageable.</p>
<p>Fig 4. Overriding sequence, values of config variables</p>
<p>Files:</p>
<p>defaults/case.yaml</p>
<p>This file has the top-level logic to merge other YAML data structures into the document-level settings. It merges the contents of the case files, default files, platform file, and everywhere else, and applies any validation from the schema/ directory. This file should also be the first file to begin with when trying to build CROW for a new modeling system.</p>
<p>defaults/downstream.yaml</p>
<p>This is a list of YES/NO switch to decide whether a downstream job should be included or not.</p>
<p>defaults/fv3_enkf.yaml</p>
<p>This is the default settings of fv3 model and enkf mechanics.</p>
<p>defaults/gfs_output_settings.yaml</p>
<p>This file contains settings specific to model output of GFS.</p>
<p>defaults/places.yaml</p>
<p>This file is designated place to put paths. For example the home directory of GFS model and home directory of CROW.</p>
<p>defaults/resources.yaml</p>
<p>This file stores default resource settings (number of cpu, length of time...) for each of the tasks in the workflow.</p>
<p>defaults/settings.yaml</p>
<p>This file is for general settings of global-workflow.</p>
<p>Testing</p>
<p>Unit test and regression test are provided within the CROW package to help streamlining future development of the package. Unit tests focus on individual functions, while regression test proves if the output could be reproduced with updated code. Like the CROW package itself, python 3.6 is a requirement to run these tests ( and to perform develop works for CROW package )</p>
<p>Unit test: Enter the unit test directory: cd tests/unittests/slurm/ Execution command: sh run_tests.sh</p>
<p>Sample output: test_AprunCrayMPI_big (test_SrunMPI.TestAprunCrayMPI) ... INFO:root:assertions not set yet ok test_AprunCrayMPI_max_ppn (test_SrunMPI.TestAprunCrayMPI) ... INFO:root:assertions not set yet ok test_FirstMax (test_exampleConfig.TestExampleConfig) ... ok test_FirstTrue (test_exampleConfig.TestExampleConfig) ... ok …...</p>
<p>Unit test is done to ensure that all functions are in place and performs as designed. This test should be conducted after porting to a new platform, or working with a new version of the corresponding workflow (ie, global-workflow).</p>
<p>Regression test: Enter the regression test directory: cd tests/regtest/ Execution command: python3 regtest.py</p>
<p>Sample output: diff /scratch4/NCEPDEV/global/noscrub/Jian.Kuang/global-workflow/workflow/CROW/tests/test_data/regtest/cache/expdir/regtest_tmp/../../../control/defs/regtest_tmp /scratch4/NCEPDEV/global/noscrub/Jian.Kuang/global-workflow/workflow/CROW/tests/test_data/regtest/cache/expdir/regtest_tmp/../../defs/regtest_tmp Differing files : ['regtest_tmp_2016021000.def']</p>
<p>diff /scratch4/NCEPDEV/global/noscrub/Jian.Kuang/global-workflow/workflow/CROW/tests/test_data/regtest/cache/expdir/regtest_tmp/../../../control/expdir/regtest_tmp /scratch4/NCEPDEV/global/noscrub/Jian.Kuang/global-workflow/workflow/CROW/tests/test_data/regtest/cache/expdir/regtest_tmp/../../expdir/regtest_tmp Identical files : ['_main.yaml', 'case.yaml', 'config.anal', 'config.fcst', 'config.post', 'config.prep', 'names.yaml', 'platform.yaml', 'user.yaml', 'workflow.yaml'] Differing files : ['config.base', 'static_locations.yaml', 'workflow.crontab', 'workflow.xml'] Common subdirectories : ['config', 'defaults', 'runtime', 'schema']</p>
<p>CROW regression test is essentially a repeatability test for workflow generation process. This test should be done before committing any changes to the CROW master branch. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
